//  Copyright (c) 2019 IBM Corporation and others.
// Licensed under Creative Commons Attribution-NoDerivatives
// 4.0 International (CC BY-ND 4.0)
//   https://creativecommons.org/licenses/by-nd/4.0/
//
// Contributors:
//     IBM Corporation
//
:projectid: microshed-testing
:page-layout: guide-multipane
:page-duration: 20 minutes
:page-releasedate: 2019-11-04
:page-guide-category: microprofile
:page-essential: true
:page-essential-order: 5
:page-description: Learn how to test a MicroProfile or Jakarta EE application using MicroShed Testing.
:page-seo-title: Testing a MicroProfile or Jakarta EE application using MicroShed Testing with Open Liberty docker container
:page-seo-description: A tutorial on how to develope test for MicroProfile microservice or Jakarta EE application by using Open Liberty development mode that provided by Liberty Maven plugin.
:guide-author: Open Liberty
:page-tags: ['MicroProfile', 'Java EE', 'Jakarta EE', 'Testing']
:page-related-guides: ['rest-intro', 'docker', 'rest-client-java']
:page-permalink: /guides/{projectid}
:repo-description: Visit the https://openliberty.io/guides/{projectid}.html[website] for the rendered version of the guide.
:common-includes: https://raw.githubusercontent.com/OpenLiberty/guides-common/master
= Testing a MicroProfile or Jakarta EE application

[.hidden]
NOTE: This repository contains the guide documentation source. To view the guide in published form, view it on the https://openliberty.io/guides/{projectid}.html[Open Liberty website].

Learn how to test a MicroProfile or Jakarta EE application using MicroShed Testing.

== What you'll learn

You will start with an existing REST application that runs on OpenLiberty, and use https://microshed.org/microshed-testing/[MicroShed Testing^] 
to write tests for the application that will exercise the application inside of a Docker container.

Often times tests may pass in dev/test environments, but fail in production because the application is
running differently in production than it is in dev/test. Luckily, we can greatly minimize these dev/prod
parity issues by testing our application as it runs in the same Docker container we'll be using in production.

=== What is Docker?

Docker is a tool that you can use to deploy and run applications with containers. You
can think of Docker like a virtual machine that runs various applications. However, unlike a typical virtual
machine, you can run these applications simultaneously on a single system and independent of
one another.

Learn more about Docker on the https://www.docker.com/what-docker[official Docker page^].

Learn how to install Docker on the https://docs.docker.com/engine/installation[official instructions page^].

[role="command"]
include::{common-includes}/gitclone.adoc[]

=== Try what you'll build

The `finish` directory in the root of this guide contains the finished application. Give it a try before you proceed.

First, look at [hotspot file=0]`PersonServiceIT` class to see what the tests look like:

PersonServiceIT.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/src/test/java/io/openliberty/guides/testing/PersonServiceIT.java[]
----

To try out the application, first go to the `finish` directory and run the following Maven 
goal to build the application and run the integration tests on an Open Liberty server in a container:
[role='command']
```
mvn verify
```

This may take some time on the first run, due to downloading dependencies and the Docker image for Open Liberty. If you 
rerun the same command again, it will be faster.

In addition to running integration tests from a cold start, you can use MicroShed Testing to run your tests on
an already running Open Liberty server, using Open Liberty development mode:

[role='command']
```
mvn liberty:dev
```

Once the Liberty server starts and you see the message `Press the Enter key to run tests on demand.`, you can press the 
`enter/return` key to run the integration tests. Once the tests finish, you can press the Enter key to run the tests again, or you 
can make code changes to the application or tests in between rerunning the tests. Development mode will automatically
recompile and update any application or test code changes that you make.

After you are done running tests in development mode, stop the Open Liberty server by typing `q` in the shell session where you ran the server and then press the `enter/return` key. 

== Bootstrapping your application for testing

Navigate to the `start` directory to begin.

Start Open Liberty in development mode, which starts the Open Liberty server and listens 
for file changes:

[role="command"]
```
mvn liberty:dev
```

Wait for the message `Press the Enter key to run tests on demand.`, and then press the `enter/return` key to run the tests. You will see that 1 test is run:

[role="no_copy"]
----
[INFO] Running integration tests...
[INFO]
[INFO] -------------------------------------------------------
[INFO]  T E S T S
[INFO] -------------------------------------------------------
[INFO] Running io.openliberty.guides.testing.PersonServiceIT
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.024 s - in io.openliberty.guides.testing.PersonServiceIT
[INFO]
[INFO] Results:
[INFO]
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] Integration tests finished.
----

To begin, annotate the `src/test/java/io/openliberty/guides/testing/PersonServiceIT.java` class with the `@MicroShedTest` annotation. This will indicate that the test class uses MicroShed Testing.

[role="code_command hotspot file=0", subs="quotes"]
----
#Update the `PersonServiceIT` class.#
`src/test/java/io/openliberty/guides/testing/PersonServiceIT.java`
----
[role="edit_command_text"]
Import [hotspot=importMicroShedTest file=0]`MicroShedTest` annotation and annotate the `PersonServiceIT` class with [hotspot=microShedTest file=0]`@MicroShedTest`.

PersonServiceIT.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::hotspots/src/test/java/io/openliberty/guides/testing/PersonServiceIT.1.java[]
----
// if use PersonServiceIT.2.java, use following:
//[source, java, linenums, role='code_column hide_tags=copyright,importInject,importMPApp,importAssertNotNull,importSharedContainerConfig,sharedContainerConfig,inject,personSvc,mpApp,container,testCreatePerson']
//----
//include::hotspots/src/test/java/io/openliberty/guides/testing/PersonServiceIT.2.java[]
//----

Next, we will define some basic information that informs MicroShed Testing if and how it should start our applictaion runtime, and what URL path the application will be available at:

[role="code_command hotspot file=1", subs="quotes"]
----
#Update the `PersonServiceIT` class.#
`src/test/java/io/openliberty/guides/testing/PersonServiceIT.java`
----
[role="edit_command_text"]
Import [hotspot=importMPApp file=1]`MicroProfileApplication` class and [hotspot=importContainer file=1]`Container` annotation, create the [hotspot=mpApp file=1]`MicroProfileApplication` application, and annotate with [hotspot=container file=1]`@Container`.

PersonServiceIT.java
[source, java, linenums, role='code_column hide_tags=copyright,importInject,importAssertNotNull,importSharedContainerConfig,sharedContainerConfig,inject,personSvc,testCreatePerson']
----
include::hotspots/src/test/java/io/openliberty/guides/testing/PersonServiceIT.2.java[]
----

The [hotspot=withAppContextRoot file=1]`withAppContextRoot(String)` method indicates what the base path of the application is. In this case, our application is deployed at http://localhost:9080/guide-microshed-testing, so the app context root is [hotspot=withAppContextRoot file=1]`/guide-microshed-testing`, which is the portion of the URL after the hostname and port.

The [hotspot=withReadinessPath file=1]`withReadinessPath(String)` method indicates what path should be polled via HTTP to determine application readiness. MicroShed Testing will automatically start or discover the MicroProfileApplication and wait for it to be ready before the tests start running. In this case, we are utilizing the default application readiness check at http://localhost:9080/health/ready[http://localhost:9080/health/ready^], which is provided by the [hotspot=mpHealth file=2]`mpHealth-2.0` feature in our server.xml configuration. When the readiness URL returns HTTP 200, the application is considered ready and the tests will begin running.

server.xml
[source, xml, linenums, role='code_column']
----
include::finish/src/main/liberty/config/server.xml[]
----

Save your changes to `PersonServiceIT` and press the `enter/return` key in your console window to rerun the tests. You will still see only 1 test running, but the output will be a bit different. Notice that MicroShed Testing is using a "hollow" configuration mode. This means it is reusing an existing application runtime for the test, and not starting up a new application instance each time you initiate a test run.

== Talking to your application with a REST client

With MicroShed Testing we exercise the application in a black-box fashion. This means the tests do not get to access internals of the application. Instead, we can only exercise the application from the "outside", most commonly with HTTP requests. To simplify the HTTP interactions, we can inject a REST client to our test like so:

[role="code_command hotspot file=0", subs="quotes"]
----
#Update the `PersonServiceIT` class.#
`src/test/java/io/openliberty/guides/testing/PersonServiceIT.java`
----
[role="edit_command_text"]
Import [hotspot=importInject file=0]`Inject` annotation, create a rest client [hotspot=personSvc file=0]`PersonService`, and annotate with [hotspot=inject file=0]`@Inject`.

PersonServiceIT.java
[source, java, linenums, role='code_column hide_tags=copyright,importAssertNotNull,importSharedContainerConfig,sharedContainerConfig,testCreatePerson']
----
include::hotspots/src/test/java/io/openliberty/guides/testing/PersonServiceIT.2.java[]
----

Here the injected type [hotspot=personSvc file=0]`PersonService` is the same [hotspot file=1]`io.openliberty.guides.testing.PersonService` class that is used in our actual application. However, the _instance_ that gets injected is a REST client proxy. So if we call `personSvc.createPerson("Bob", 42)`, what actually happens is the REST client makes an HTTP POST request to the running application at http://localhost:9080/guide-microshed-testing/people[http://localhost:9080/guide-microshed-testing/people^] which triggers the corresponding Java method in the application.

PersonService.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/src/main/java/io/openliberty/guides/testing/PersonService.java[]
----


== Writing your first test

Now that the setup is complete, we can write our first test case. We will start by testing the basic "create person" use case for our REST-based application. To do this, we use the REST client injected by MicroShed Testing to make the HTTP POST request to our application and read the response:

[role="code_command hotspot file=0", subs="quotes"]
----
#Update the `PersonServiceIT` class.#
`src/test/java/io/openliberty/guides/testing/PersonServiceIT.java`
----
[role="edit_command_text"]
Import [hotspot=importAssertNotNull file=0]`assertNotNull` static method and write the test logic in [hotspot=testCreatePerson file=0]`testCreatePerson()`.

PersonServiceIT.java
[source, java, linenums, role='code_column hide_tags=copyright,importSharedContainerConfig,sharedContainerConfig']
----
include::hotspots/src/test/java/io/openliberty/guides/testing/PersonServiceIT.2.java[]
----

Save the changes. Then, press the `enter/return` key in your console window to run the test. You will see that the test ran again and this time exercised the REST endpoint of your application, including the response of your application's endpoint.

[role="no_copy"]
----
INFO org.microshed.testing.jaxrs.RestClientBuilder  - Building rest client for class io.openliberty.guides.testing.PersonService with base path: http://localhost:9080/guide-microshed-testing/ and providers: [class org.microshed.testing.jaxrs.JsonBProvider]
INFO org.microshed.testing.jaxrs.JsonBProvider  - Response from server: 1809686877352335426
----

Then, add more tests.

[role="code_command hotspot file=1", subs="quotes"]
----
#Replace the `PersonServiceIT` class.#
`src/test/java/io/openliberty/guides/testing/PersonServiceIT.java`
----

PersonServiceIT.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::hotspots/src/test/java/io/openliberty/guides/testing/PersonServiceIT.3.java[]
----

Tests [hotspot=testMinSizeName file=1]`testMinSizeName()`, [hotspot=testMinAge file=1]`testMinAge()`, [hotspot=testGetPerson file=1]`testGetPerson()`, [hotspot=testGetAllPeople file=1]`testGetAllPeople()`, and [hotspot=testUpdateAge file=1]`testUpdateAge()` are added.


Save the changes, and  press the `enter/return` key in your console window to run the tests.

== Testing outside of development mode

Running the tests against a pre-started Liberty server is very convenient for local development, but this may be tedious to set up in non-dev scenarios such as a CI/CD pipeline. For this reason, MicroShed Testing can start and stop the application runtime before and after the tests are run. This is primarily accomplished using Docker and Testcontainers.

To test outside of development mode, first exit development mode by typing `q` in the shell session where you ran the server and then press the `enter/return` key.

Next, run the tests from a "cold start" by running the command:
[role='command']
```
mvn verify
```

Running tests from a cold start will take a little longer than running the tests from development mode, since the application runtime needs to be started each time. However, the benefits of this mode are:

- A clean instance is used on each test run, for consistent results
- Automatically hooks into many existing build pipelines that are set up to run the `integration-test` phase

== Sharing configuration across multiple classes

Typically, projects have multiple test classes that all exercise the same type of application deployment. For these cases, it is useful to reuse existing configuration and application lifecycle across multiple test classes.

First, create another test class.

[role="code_command hotspot file=0", subs="quotes"]
----
#Create the `ErrorPathIT` class.#
`src/test/java/io/openliberty/guides/testing/ErrorPathIT.java`
----

ErrorPathIT.java
[source, java, linenums, role='code_column hide_tags=copyright,importSharedContainerConfig,sharedContainerConfig']
----
include::hotspots/src/test/java/io/openliberty/guides/testing/ErrorPathIT.java[]
----

`ErrorPathIT` test class has the same [hotspot=container file=0]`@Container` configuration and rest client [hotspot=personSvc file=0]`PersonService` as the `PersonServiceIT` class.

Now, run the tests again outside of development mode:
[role='command']
```
mvn verify
```

You will notice that tests for both `PersonServiceIT` and `ErrorPathIT` classes run, but a new server is started for each test class, resulting in a longer test runtime.

To solve this issue, common configuration can be placed in a class that implements `SharedContainerConfiguration`.
  
[role="code_command hotspot file=1", subs="quotes"]
----
#Create the `AppDeploymentConfig` class.#
`src/test/java/io/openliberty/guides/testing/AppDeploymentConfig.java`
----

AppDeploymentConfig.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/src/test/java/io/openliberty/guides/testing/AppDeploymentConfig.java[]
----

Once the common configuration is created, the test classes can be updated to reference this shared configuration.

Remove the container code in `PersonServiceIT` class.
[role="code_command hotspot file=2", subs="quotes"]
----
#Update the `PersonServiceIT` class.#
`src/test/java/io/openliberty/guides/testing/PersonServiceIT.java`
----
[role="edit_command_text"]
Remove [hotspot=importMPApp hotspot=importContainer file=2]`import` statements and [hotspot=container hotspot=mpApp file=2]`MicroProfileApplication app` field.

PersonServiceIT.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::hotspots/src/test/java/io/openliberty/guides/testing/PersonServiceIT.2.java[]
----

Annotate the `PersonServiceIT` class with `@SharedContainerConfiguration` referencing the shared configuration class `AppDeploymentConfig`.
[role="code_command hotspot file=3", subs="quotes"]
----
#Update the `PersonServiceIT` class.#
`src/test/java/io/openliberty/guides/testing/PersonServiceIT.java`
----
[role="edit_command_text"]
Import [hotspot=importSharedContainerConfig file=3]`SharedContainerConfig` annotation, and annotate the `PersonServiceIT` class with [hotspot=sharedContainerConfig file=3]`@SharedContainerConfig`. 

PersonServiceIT.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/src/test/java/io/openliberty/guides/testing/PersonServiceIT.java[]
----

Then, update the `ErrorPathIT` class similarly to remove the container code.
[role="code_command hotspot file=4", subs="quotes"]
----
#Update the `ErrorPathIT` class.#
`src/test/java/io/openliberty/guides/testing/ErrorPathIT.java`
----
[role="edit_command_text"]
Remove [hotspot=importMPApp hotspot=importContainer file=4]`import` statements and [hotspot=container hotspot=mpApp file=4]`MicroProfileApplication app` field

ErrorPathIT.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::hotspots/src/test/java/io/openliberty/guides/testing/ErrorPathIT.java[]
----

Annotate the `ErrorPathIT` class with `@SharedContainerConfiguration`.
[role="code_command hotspot file=5", subs="quotes"]
----
#Update the `ErrorPathIT` class.#
`src/test/java/io/openliberty/guides/testing/ErrorPathIT.java`
----
[role="edit_command_text"]
Import [hotspot=importSharedContainerConfig file=5]`SharedContainerConfig` annotation, and annotate the `ErrorPathIT` class with [hotspot=sharedContainerConfig file=5]`@SharedContainerConfig`. 

ErrorPathIT.java
[source, java, linenums, role='code_column hide_tags=copyright']
----
include::finish/src/test/java/io/openliberty/guides/testing/ErrorPathIT.java[]
----

Now, if you rerun the tests, they will run in about half the time because the same server instance is being used for both test classes.
[role='command']
```
mvn verify
```

== Great work! You're done!

You developed automated tests for a REST service in Open Liberty by using MicroShed Testing and Liberty development mode.

== Related Links

Learn more about MicroShed Testing.

https://microshed.org/microshed-testing/[View the MicroShed Testing website^]

include::{common-includes}/attribution.adoc[subs="attributes"]
